Introduction:
=============
Yzis is a vi-compatible editor that is composed of a generic vi engine and 
independant GUI. It is developped in C++ and relies on Qt for the some of the
background classes (lists and strings mainly). A KDE GUI and a ncurses based
GUI are available.


Building Yzis:
==============
To compile Yzis, it's better to have TinyQ installed for performance
improvment. You can use the --with-tinyq-dir to indicate your TinyQ prefix.
However, you can use a full Qt (>3.x) to compile the whole Yzis but that will
slow down "yzis" (ncurses) startup because the system has to load the whole Qt
library.

In a near future we hope to drop TinyQ and just keep Qt (4.x), since Qt should be splitted into different libraries (thus dropping the need of TinyQ ;)

To be honest I have not tried to compile with TinyQ for ages, so it's probably safer/easier to use Qt 3.1 or later :)
For Kyzis , KDE 3.2 is required.

Licenses:
=========
libyzis is published under LGPL. See COPYING.LGPL for more
details.  
kyzis and nyzis are published under GPL. See COPYING for more
details.


History:
========
Before working on Yzis, the author (Mickael Marchand, Thomas Capricalli and
Philippe Fremy) had been working on GVim. GVim is clearly the best vi
compatible editor today. It contains tons of features, which are very clear
improvements upon the original vi: visual selection, unlimited undo, powerful
syntax highlighting, script language, splitted windows, ...

We did two things with GVim. First, we ported it on KDE and created KVim. The
second step was to make KVim embeddable as an editor component into any KDE
application. The idea was to be able to use a vi editor anywhere: in KDevelop,
in Kate, in KMail, ... We managed to complete both tasks but the second one
was very difficult to achieve and a number of problems could not be overcome.
For example, kvim can not have multiple windows on the same buffer, and thus
won't integrate in Kate. 

While working with the gvim code base, we have been comfronted with a growing
amount of difficulites:
- there is a huge pile of C files without much documentation.
- it is difficult to find one's way through the code. 
- the code was written in C and has very little abstraction, which make it
  difficult to follow.
- the vi engine is tied to the concept of console editor. We have to add hacks
  after hacks to make it work as a graphical component (for example, we need
  to fork, embed a graphical window, and run an event loop at full speed while
  still not taking the whole CPU).
- the main author and contributores do not have time to work anymore on gvim.
  The development is very slow and patches are left behind
- the main author is very reluctant to add any small change, even those that
  won't affect the current behaviour
- the codebase is very big and the author does not want to introduce any new
  feature, in fear of breaking something.

So, on one side we had implementation limitations and problems, on the other
side it was not possible to do any new developments on the editor. We
discussed that with the GVim team and came to the conclusion that it was not
possible to work with GVim to have a vi-like editor in KDE as a good
component.

At this point, the decision was simple. Either spend lot of time in working
around limitations of Gvim, or start a new vi editor. Kudos to Mickael
Marchand who took over the second decision. This decision was taken shortly
before Fosdem 2003. The design documents and the name were hacked during the
Fosdem.

Mickael put up a website, a subversion server, mailing lists and started
coding. To avoid the many problems of gvim, we took the following decisions:
1. clearly separate the vi engine from the gui
2. use C++ to provide a clean design
3. abstract the views, the buffer and the gui in the engine
4. have a KDE gui
5. have a text gui
6. provide a C interface in case a hard-core C coder wants to contribute
7. use some Qt classes for the engine. Qt would bring a string class that
handles unicode correctly (multibyte support is knightmare in gvim), efficient
lists implementations, and other goodes. Moreover, we were very familiar and
efficient with Qt.
8. Use tinyQ as a backup solution for the people not willing to link with Qt
just for a few template classes.

Over the time, maintaining a C binding to C++ turn out to be quite tedious and
time consuming. It would also make the code quite complicated. So the C
binding was dropped and yzis started to develop slowly but surely.

