
/** \page arch_overview Architecture Overview

\section naming_conv Naming convention 

It's not as if I still perfectly agree with the naming convention, but
until we possibly change it, it needs to be respected for coherency.
Classes in the core libyzis are prefixed with \e YZ like in 
YZBuffer or YZView.
Classes in client specific code have yet another letter prefixed. The
letter are \e G, 
\e Q, 
\e K, 
\e N for Gtk, Qt, KDE
and ncurses clients, respectively.

\section souce_code_tree Source code tree
Here's a brief description of yzis source tree :

\code
yzis
|-- apidoc              # generated by doxygen, html API documentation
|-- build               # cmake stores all generated files there
|-- cmake               # files used by cmake
|-- debian              # files used for debian packaging
|-- doc                 # documentation (this handbook)
|-- gyzis               # first shot at gtk client, obsolate/unmaintained
|-- kyzis               # kde client and kde embedable component
|-- libyzis             # Yzis core, static lib shared by all clients
|-- nyzis               # ncurses client
|-- qyzis               # Qt only client
|-- scripts             # (lua) scripts installed with yzis
|-- syntax              # syntax highlighting scripts
|-- tests               # unit testing framework
\-- translations        # translations files
\endcode

So, code-wise, you basically have a common core, found in the dir
\e libyzis, which is a static library. It contains all GUI independant
code. Then, each client has its own directory, with the GUI dependant code,
which links against libyzis to create the executable.

As of december 2006, the purpose is to first make the \e ncurses client
and the <em>Qt only</em> client available, then the \e KDE client and
embedable component, and then others.

\section part_what Which part handles what ?

The libyzis core handles files (loading/modifying/saving), commands
interpretation, scripts interpretation (lua, highlighting), and lot of
common stuff for rendering.
It has some abstract classes about GUI, which provide APIs and basic stuff.
Most often client will inherit those classes.
It also contains some generic code (debug).

An important point is the event loop handling. The \e client is
responsible for handling the event loop. The \e client (translates and)
sends events to libyzis which will possibly call some GUI dependant code to
render some modification, and then returns to the GUI loop handling..

\section core_classes Core classes

We describe here the few most important classes in \e Yzis, and how
they interact.

\subpage YZBuffer

Being a file editor, \e Yzis code is centered around a class handling
files. They are either empty file (like when you start "nyzis"), or a file on
the filesystem ("nyzis foo.c").
This class is responsible for loading, saving, and modifying the file
(YZBuffer::insertChar() for example). It keeps track of all
views on this file, if the file is modified or not, filesystem names, and so
on.

\subpage YZSession

A session is basically a client application instance, from the core point
of view. A session can have one or more files opened, and one or more views,
or "windows" opened. The session is responsible for creating and handling
both views and buffers (see YZSession::createView(), YZSession::createBufferAndView(), YZSession::createBuffer() ).

\subpage YZView

A view is a GUI component displaying part of a file, within a session. As
such, it depends on both: the constructor needs both a
YZSession and a YZBuffer. This is the class where rendering is
done, closely with the core.

\section data_paths Data paths

In this section, we describe the paths followed by the data (file,
keyboard) within \e Yzis architecture.

During initialisation of the program, an instance of YZSession is
created (or a subclass, most probably). This instance is unique, and is
always present. Most of high level API is here (like creating/deleting other
important objects).
For example, if you want to open a file, and create an associated view, you
can use:
\code
session->createBufferAndView( myname );
\endcode

At every time, the session has a 'current view', which is the one receiving
user input. For example in nyzis, if you haven't use the \e split
feature, there's only one view displayed at any time, even if several
files are opened.  This is the current view. In Qyzis or Kyzis, on the
other way, several views are displayed, but only one window has the focus:
this is the current view from YZSession's point of view.

The \e client handles the event loop. When a key event is received, it is sent
to the libyzis core using the current view. For example in
nyzis/nsession.cpp we can read:
\code
currentView()->sendKey( QString( QChar( c ) ), modifiers );
currentView()->sendKey( "<CTRL>]" );
\endcode

The core does all what is needed: store the character in appropriate
buffer, update all views for this buffer, if the character is \e enter,
then some action might be taken, such as executing a command or whatever,
depending on the current mode.

Yzis core uses the API to call the upper GUI layer to display. (details
are in section rendering).

*/
