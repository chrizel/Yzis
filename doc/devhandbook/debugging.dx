/** 

\page debugging Debugging Yzis

\section yzis_log_system Yzis Log System

Debugging in Yzis is based on a flexible log system.

Many developers take debugging as a kind of printf. They put a lot of
printf code during debug and then comment it once the code is supposed to
be working. This has several drawbacks:
- when you need to debug a specific area, you need to uncomment a lot of
stuff
- if you want to debug a program which you can not control (on somebody
else computer), you can not have the debug log
- you get either too much logs because there is too much debug statements,
or not enough information because the debug statement have been kept
minmal.

The proper way for good debugging is a good log system. The log system of
Yzis has several features:
- output can be sent to file, stdout, stderr
- 4 log levels: debug, warning, error and fatal
- the debug log can be assigned to areas and subareas
- each area can have its own log level, indepandentely of the others.
- the log level areas can be controlled dynamically, either with a .yzdebugrc
  file or with command line arguments.

With such a system, the developers are encouraged to put as much information
as possible in the debug log, knowing that they can easily disable or enable
it when necessary.

Having a lot of precise debug log allows to follow Yzis execution path very
accurately and is very practical to learn what Yzis is doing and how.

The debugging system is described mainly in debug.h , YZDebugBackend and
YZDebugStream .

\section debug_with_gdb Debugging Yzis with gdb

In addition to using the log system, running Yzis inside a debugger is a good
way to diagnose crashes or find bugs. Step by step execution or
breakpoints are a useful tool.

\subsection debug_build Building yzis with debugging support

Building yzis with debugging support allows to diagnose crashes, or to run
Yzis in gdb - the Gnu Debugger.

Make sure you build yzis with debugging enabled. Follow the instructions at the
\subpage building_yzis page, and you should be fine.

\subsection debugging_tools Gdb and more

First of all you need a recent version of gdb, the text ui used in the example
below requires gdb version 5.1 or newer.

You should also download the gdb macros from the KDE project:

\verbatim
wget "http://websvn.kde.org/*checkout*/trunk/KDE/kdesdk/scripts/kde-devel-gdb"
\endverbatim

Put this file in a smart place and source it in your ~/.gdbinit:

\verbatim
source /path/to/kde-devel-gdb
\endverbatim

This enables you to print the contents of QStrings and other Qt objects.

\subsection using_gdb Using the GNU debugger (gdb) to debug yzis

This is not an gdb tutorial, if you want to learn to use gdb you can find plenty
of tutorials by googling.
In this example I will use gdb's text ui and debug a qyzis session.

To start debugging, type
\verbatim
gdbtui qyzis
\endverbatim

Your screen should now look something like this:

\image html gdb1.png "main()"

The basic commands are:

- \b b
Sets a breakpoint
- \b run
Starts the program with given parameters
- \b cont
Continues execution to the next breakpoint (if any) after stopping at a breakpoint
- \b bt
Prints a backtrace of all stack frames. This is what you will use to track down
segfaults ;-)
- \b p
Prints the value of a variable or a function/method. This lets you examine the
value of ints, strings etc. Note: this doesn't work very well for QString
objects, to print the contents of a QString, use the <b>printq4string</b> macro defined
in kde-devel-gdb
- \b n
Continues to the next line of code as shown on screen. If a subroutine is
called, you won't step in it
- \b step
Steps exactly one line of code, including subroutines. If you are on a line
containing "int a = foo()", this will take you in to the function foo(), while n
would have skipped to the next line on screen

To switch between the source code view and the command line in the text ui,
press <b>control+x</b> and then <b>control+o</b>.

*/


