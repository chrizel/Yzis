
% pdflatex book template
% this file is part of the kdissert templates
% http://freehackers.org/~tnagy/kdissert/index.html
% created by Thomas Nagy <tnagy2^8@yahoo.fr> in 2004
%
% permission is granted to redistribute copies and
% derivated work of this file without restrictions
%

% main latex includes
\documentclass[a4paper,12pt]{report}
%\usepackage[T1]{fontenc} % on some systems T1 looks ugly
%\usepackage[cyr]{aeguill}

\usepackage[pdftex]{graphicx}
\DeclareGraphicsExtensions{.png,.pdf,.jpg,.jpeg}

\usepackage[pdftex,
bookmarks=true,
bookmarksnumbered=true,
pdfpagemode=None,
pdfstartview=FitH,
pdfpagelayout=SinglePage,
colorlinks=true,
urlcolor=magenta,
pdfborder={0 0 0}
]{hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%interesting settings for the page layout

%\setlength{\hoffset}{-18pt}
%\setlength{\oddsidemargin}{0pt}  % left margin, odd pages
%\setlength{\evensidemargin}{9pt}  % left margin, even pages
%\setlength{\marginparwidth}{54pt} 
%\setlength{\textwidth}{481pt}  % set the text width to about 17cm
%\setlength{\marginparsep}{7pt}
%\setlength{\topmargin}{0pt}  % no margin on top
%\setlength{\headheight}{13pt}
%\setlength{\headsep}{10pt} 
%\setlength{\footskip}{27pt}
%\setlength{\textheight}{700pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% miscalleneous packages

% \usepackage[frenchb]{babel} % use this if you are French
% \usepackage{verbatim} % include eg: source code easily
% \usepackage[utf8]{inputenc} or \usepackage[latin1]{inputenc}

% If you are on Fedora Core you may have problems with accents
% in this case replace the accentuated characters like this:
%
%  é -> \'e
%  è -> \`e
%  ê -> \^e and so on
%
% To automate the replacement you can make yourself a script
% here is a handy command-line for doing this:
% perl -pi -e "s/é/\\\'e/g" main.tex

\usepackage{amsmath}
% math extension - one probably wants to use symbols like '[' (written as '$[$')
% or $\epsilon$

% see mymacros.sty - print nice chapter headers

\makeatletter
\def\@makechapterhead#1{%
  \vspace*{50\p@}%
  {\parindent \z@ \raggedright \normalfont
    \interlinepenalty\@M
    \ifnum \c@secnumdepth >\m@ne
        \Huge\bfseries \thechapter\quad
    \fi
    \Huge \bfseries #1\par\nobreak
    \vskip 40\p@
  }}

\def\@makeschapterhead#1{%
  \vspace*{50\p@}%
  {\parindent \z@ \raggedright
    \normalfont
    \interlinepenalty\@M
    \Huge \bfseries  #1\par\nobreak
    \vskip 40\p@
  }}
\makeatother



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% headers and footers for your document
\usepackage{fancyhdr}

% count the number of pages for display on footer
\usepackage{lastpage}

% width of the line for headers and footers
\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}
%\addtolength{\headwidth}{\marginparsep}

% uncomment the following lines for headers
% the following command need picture files: "logo-school.jpg" 
% and "logo-company.jpg" in the project directory
%
%        \lhead{\sl \includegraphics[height=1.1cm]{logo-school}}
%        \chead{}
%        \rhead{\sl \includegraphics[height=1.2cm]{logo-company}}


\usepackage{ucs}
\usepackage[utf8]{inputenc}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%document headers and footers
\lhead{}
\chead{}
\rhead{}
\lfoot{The Yzis Development team}
\cfoot{\thepage/\pageref{LastPage}}
\rfoot{ \today } % -> \rfoot{\number\month/\number\day/\number\year} 
\pagestyle{fancyplain}



\title{The Yzis Developer Handbook}
\date{\today}
\author{The Yzis Development team}

\begin{document}
\maketitle
\tableofcontents

% 

\chapter{Architecture overview}

\section{Naming convention}
It's not as if I still perfectly agree with the naming convention, but
until we possibly change it, it needs to be respected for coherency.
Classes in the core \verb+libyzis+ are prefixed with \emph{YZ} like in 
\verb+YZBuffer+ or \verb+YZView+.
Classes in client specific code have yet another letter prefixed. The
letter are \emph{G}, \emph{Q}, \emph{K}, \emph{N} for Gtk, Qt, KDE
and ncurses clients, respectively.

\section{Source code tree}
Here's a brief description of yzis source tree :
\begin{verbatim}
yzis
|-- apidoc              # generated by doxygen, html API documentation
|-- build               # cmake stores all generated files there
|-- cmake               # files used by cmake
|-- debian              # files used for debian packaging
|-- doc                 # documentation (this handbook)
|-- gyzis               # first shot at gtk client, obsolate/unmaintained
|-- kyzis               # kde client and kde embedable component
|-- libyzis             # Yzis core, static lib shared by all clients
|-- nyzis               # ncurses client
|-- qyzis               # Qt only client
|-- scripts             # (lua) scripts installed with yzis
|-- syntax              # syntax highlighting scripts
|-- tests               # unit testing framework
\-- translations        # translations files
\end{verbatim}

So, code-wise, you basically have a common core, found in the dir
\verb+libyzis+, which is a static library. It contains all GUI independant
code. Then, each client has its own directory, with the GUI dependant code,
which links against \verb+libyzis+ to create the executable.

As of december 2006, the purpose is to first make the \emph{ncurses} client
and the \emph{Qt only} client available, then the \emph{KDE} client and
embedable component, and then others.

\section{Which part handles what?}

The \verb+libyzis+ core handles files (loading/modifying/saving), commands
interpretation, scripts interpretation (lua, highlighting), and lot of
common stuff for rendering.
It has some abstract classes about GUI, which provide APIs and basic stuff.
Most often client will inherit those classes.
It also contains some generic code (debug).

An important point is the event loop handling. The \emph{client} is
responsible for handling the event loop. The \emph{client} code will do
call to \verb+libyzis+.

\section{Core classes}

We describe here the few most important classes in \emph{Yzis}, and how
they interact.

\verb+YZBuffer+

Being a file editor, \emph{Yzis} code is centered around a class handling
files. They are either empty file (like when you start "nyzis"), or a file on
the filesystem ("nyzis foo.c").
This class is responsible for loading, saving, and modifying the file
(\verb+insertChar()+ for example). It keeps track of all views on this file,
if the file is modified or not, filesystem names, and so on.

\verb+YZSession+

A session is basically a client application instance, from the core point
of view. A session can have one or more files opened, and one or more views,
or "windows" opened. The session is responsible for creating and handling
both views and buffers (see \verb+createView()+, \verb+createBufferAndView()+,
\verb+createBuffer()+).

\verb+YZView+

A view is a GUI component displaying part of a file, within a session. As
such, it depends on both: the constructor needs both a
\verb+YZSession+ and a \verb+YZBuffer+. This is the class where rendering is
done, closely with the core.

\section{Data paths}
In this section, we describe the paths followed by the data (file,
keyboard) within \emph{Yzis} architecture.

During initialisation of the program, an instance of \verb+YZSession+ is
created (or a subclass, most probably). This instance is unique, and is
always present. Most of high level API is here (like creating/deleting other
important objects).
For example, if you want to open a file, and create an associated view, you
can use
\begin{verbatim}
session->createBufferAndView( myname);
\end{verbatim}

At every time, the session has a 'current view', which is the one receiving
user input. For example in nyzis, if you haven't use the \emph{spilt}
feature, there's only one view displayed at any time, even if several
files are opened.  This is the current view. In Qyzis or Kyzis, on the
other way, several views are displayed, but only one window has the focus:
this is the current view from \verb+YZSession+'s point of view.

The \emph{client} handles the event loop. When a key event is received, it is sent
to the \verb+libyzis+ core using the current view. For example in
\verb+nyzis/nsession.cpp+ we can read:
\begin{verbatim}
currentView()->sendKey( QString( QChar( c ) ), modifiers );
currentView()->sendKey( "<CTRL>]" );
\end{verbatim}

The core will do all what is needed: store the character in appropriate
buffer, update all views for this buffer, if the character is \emph{enter},
then some action might be taken, such as executing a command or whatever,
depending on the current mode.

Yzis core will use the API to call the upper GUI layer to display. (details
are in section \ref{rendering}).



\chapter{Components description}

\section{Modes}


\section{Rendering}
\label{rendering}

Loic?

plan: global overview, messages exchanged between core and client.

TODO: interval, cursors, color, highlighting.

\section{Unit testing}

Phil?

\section{Debugging and logging}

Phil?

you can use the following macros
\begin{verbatim}
YZASSERT_MSG( assertion, msg )
YZASSERT( assertion )
YZASSERT_EQUALS( a, b )
\end{verbatim}

If you want to write some debugging message, please use the following
streams:

\begin{verbatim}
yzDebug() yzWarning() yzError() yzFatal()
\end{verbatim}

You can add an argument(text, as in "rendering", for example) to specify an
debug area. Example:

\begin{verbatim}
yzDebug("rendering") << "my message" << endl;
\end{verbatim}

Most clients are graphical GUIs, and as such,
they can use the \verb+stdout+ or \verb+stderr+ to print debugging
messagse. But nyzis is using the console for user interaction, and this
is not possible. This is why yzis debug messages are written in a file such
as \verb+/tmp/yzisdebug-orzel.log+. To see them, I recommand the following
command (use an alias):

\begin{verbatim}
tail --follow=name /tmp/yzisdebug-orzel.log
\end{verbatim}

Use this command from another console. This will give you an constantly updating
view of the log file.

\section{Scripting}

who?

\chapter{nyzis, ncurses client}

Thomas.

\chapter{qyzis, Qt-only client}

Thomas.

\chapter{Developer FAQ}

\section{What's the mess with symbol \texttt{scroll}?}

The ncurses library (only used by nyzis) defines a MACRO with such a name.
This creates big clashes with Qt API as some classes (QWidget for example)
have methods with this name. Nyzis handles this using some hack (see
viewWidget.h), but to ease handling this, the word \verb+scroll+ should
just not be used anywhere in libyzis.

\appendix

\chapter{How to set up set your distribution for building yzis}

\section{(K)ubuntu 6.10 (Edgy Eft)}

First of all, if you haven't already done so, you have to add the
\emph{universe} repository by uncommenting the appropriate lines in
\texttt{/etc/apt/sources.list}. This is needed to install cmake.

\subsection{Essential tools}
To build yzis from source code You'll need to install the the following packages
and their dependencies using apt-get:

\texttt{sudo apt-get install subversion cmake build-essential libqt4-dev liblua5.1-0-dev
libncursesw5-dev libmagic-dev}

\subsection{\TeX}

Yzis uses the \LaTeX document preparation system for documentation. To be able
to build this documentation you'll need to install these \TeX{} Live packages
with dependencies:

\texttt{sudo apt-get install texlive-base texlive-base-bin texlive-doc-base
texlive-fonts-recommended texlive-latex-base texlive-latex-recommended
texlive-pdfetex texlive-latex-extra}

\subsection{Doxygen}
To be able to build the API documentation with oxygen, install doxygen:

\texttt{sudo apt-get install doxygen}

\section{Gentoo}
There are two ways for installing the latest yzis version on your system.

\begin{enumerate}
	\item You can download the yzis ebuild from the Gentoo bug database:

\url{http://bugs.gentoo.org/show\_bug.cgi?id=48552}

Installing this ebuild (and updating the date in the ebuild's name) you will
always have the newest yzis development snapshot installed.

If you need instructions on installing custom ebuilds, please refer to:

\url{http://linuxreviews.org/gentoo/ebuilds/} or
\url{http://gentoo-wiki.com/HOWTO\_Installing\_3rd\_Party\_Ebuilds}

\item You can also check out the sources directly from the yzis svn repository and
compile them on your own. See section \ref{checkout}.
\end{enumerate}

\subsection{Essential tools}
To build yzis you'll need to have the following packages installed on your system:

\begin{itemize}
\item $>$=x11-libs/qt-4.2
\item sys-devel/gettext
\item =dev-lang/lua-5*
\item sys-apps/file         
\item $>$=sys-libs/ncurses-5.4
\item $>$=dev-util/cmake-2.4.1
\item dev-util/subversion
\end{itemize}

If you are installing yzis using the custom ebuild (first method), it will check for the necessary dependencies, except for subversion. If you are compiling the sources on your own (second method), you can easily check for the needed tools with the \texttt{eix} command.

If you need to install any missing tool (e.g. subversion) you can do as follows:

\texttt{emerge -av subversion}

It is also advisable to have a subversion client installed, e.g kdesvn, esvn, etc. for easier handling of the subversion repository and sandbox.

It can happen that some required tool versions are masked in portage. In this case you can unmask them  with the following command:

\texttt{echo =<category>/<package>-<version> >> \\\
/etc/portage/package.keywords}

\subsection{\TeX}

Yzis uses the \LaTeX document preparation system for documentation. To be able
to build this documentation you'll need to install these \TeX{} Live packages
with its dependencies. Since the texlive package is currently hardmasked on Gentoo, we suggest you to use the tetex package, which will also do the job:

\texttt{emerge -av tetex}

\subsection{Doxygen}
To be able to build the API documentation with oxygen, install doxygen:

\texttt{emerge -av doxygen}

\end{document}

