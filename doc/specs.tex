\documentstyle[]{article}

\def\version{$Id: specs.tex,v 1.3 2003/04/25 12:45:27 mikmak Exp $}

\begin{document}

\title{Yzis Technical Reference}
\author{Mickael Marchand\\{\normalsize\tt marchand@yzis.org}}
\date{22 April 2003}
\maketitle

\newpage

\tableofcontents

\newpage
\section{About}

This document attempts to describe the internals of Yzis.\newline
At the time of this writing nothing is frozen yet, so this documentation is not exhaustive but I will try to keep it the most up to date possible.\newline
\newline
{\it This document is published under the Free Documentation License.}

\newpage
\section{History}
Project initially started in February 2003 during the FOSDEM in Bruxelles.

\newpage
\section{Introduction}
Yzis is a text editor developed using advanced design technics to provide as much features
than editors like vim and emacs with the same reliability but with adding a great flexibility and the best
modularisation possible.\newline
The goal is to provide a fast, reliable, highly configurable and nice looking editor. Yzis is also aimed at "embedding" inside other applications. This should provide a great tool for Integrated Development Environments like KDevelop.\newline
The idea of Yzis is to separate the "editor processing" from the User Interface so that one can develop a new User Interface (either Console or Graphical) easily and adapt it to the environment he wishes while keeping the whole features of Yzis.\newline


%         INTERNALS

\newpage
\section{Internals}
\subsection{Code Structure}
The most important part of Yzis, is based on a core library written in C++. It uses TinyQ or Qt as its backend (TinyQ is adviced for performance). Thanks to TinyQ/Qt Yzis does not rewrite its own unicode, internationalisation, file access, regular expression ... handlers. TinyQ/Qt are also highly portable so porting Yzis to these supported systems should be easy.\newline
User interfaces uses this core library to create the complete editor. Currently, a ncurses and a KDE interface are being worked on.  The interaction between the library and the UIs (User Interfaces) is handled through a set a common interfaces :
\begin{itemize}
\item YZBuffer : a class describing a buffer object (a buffer is an opened/new file)
\item YZView : a class describing a view on a buffer (a view is {\bf always} linked to a buffer
\item Gui : a class allowing libyzis to control some of the UI itself
\end{itemize}
The core Yzis provides some other classes :
\begin{itemize}
\item YZSession : an object describing the running instance of Yzis (list of buffers for e.g.)
\item YZCommand : a simple object mapping a keystroke to a method inside the core Yzis or in a plugin
\end{itemize}
The core Yzis will also provides some extensions interface so that third party addons can be plugged in at runtime :
\begin{itemize}
\item YZPlugin : an interface to write high level plugins
\end{itemize}

\newpage
\subsection{Session handling}

\newpage
\subsection{Command handling}

\newpage
\subsection{Scripting support}

\newpage
\subsection{Plugins}


%        RUNTIME
\newpage
\section{Runtime}
\subsection{Event loop}
The event loop is basically handled by libyzis. However, libyzis does not {\bf
run} this event loop. This means that any GUI is responsible for
pushing/getting events into the event loop.

\newpage
\subsection{Graphical/Console User interfaces}
%\subsection{Display}
%\subsection{Inputs}
\newpage
\subsection{Plugins}


\vfill
$ \version\ $
\eject
\end{document}

